*/ We are playing the Guess Game. The game is as follows:

I pick a number from 1 to n. You have to guess which number I picked (the number I picked stays the same throughout the game).

Every time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess.

You call a pre-defined API int guess(int num), which returns three possible results:

-1: Your guess is higher than the number I picked (i.e. num > pick).
1: Your guess is lower than the number I picked (i.e. num < pick).
0: your guess is equal to the number I picked (i.e. num == pick).
Return the number that I picked. 

 

Example 1:

Input: n = 10, pick = 6
Output: 6
Example 2:

Input: n = 1, pick = 1
Output: 1
Example 3:

Input: n = 2, pick = 1
Output: 1*/ 
=========================================================================================================================================================================
class Solution {
public:
    int guessNumber(int n) {
        int low = 1;
        int high = n;

        while(low <= high) {
            int mid = low + (high - low) / 2;

            int res = guess(mid);

            if(res == 0) {
                return mid;          // correct guess
            }
            else if(res == -1) {
                high = mid - 1;      // guess too high
            }
            else {
                low = mid + 1;       // guess too low
            }
        }
        return -1; // will never reach here
    }
};



===========================================================================================================================================================================
1️⃣ What the problem is really about

You are not asked to “guess randomly”.

You are given:

A search space: numbers from 1 to n

A comparison oracle: guess(x)
This oracle tells you whether:

x is too large

x is too small

x is correct

This is exactly the same information you get when doing comparisons in a sorted array.

So conceptually:

The problem reduces to searching for an unknown value in a sorted range using comparison feedback.

2️⃣ Why Binary Search is the correct strategy

Binary search works when:

The search space is ordered

You can compare a guess and know whether the answer lies left or right

This problem satisfies both:

Numbers 1 → n are naturally sorted

guess() tells you direction (higher / lower)

Optimality

Binary search:

Eliminates half the remaining search space per guess

Finds the number in O(log n) time

This is optimal for comparison-based searching

Any linear guessing (1, 2, 3...) would be O(n) and inefficient.

3️⃣ Logical flow of the algorithm

We maintain an invariant:

The picked number always lies in the range [low, high]

Initialization
low = 1
high = n

Loop

Compute the midpoint:

mid = low + (high - low) / 2


(avoids integer overflow)

Call the API:

result = guess(mid)


Adjust the search space:

result == 0 → found the number

result == -1 → guessed too high → discard right half

result == 1 → guessed too low → discard left half

Each step preserves the invariant and reduces the range.

4️⃣ Why the loop is guaranteed to terminate

Each iteration strictly shrinks the range

The range size decreases exponentially

Eventually low == high == pick

Therefore:

No infinite loops

Guaranteed termination

5️⃣ Time and space complexity
Time

Each guess halves the range

Maximum guesses = log₂(n)

Time Complexity: O(log n)

Space

Uses only a few variables

Space Complexity: O(1)
